const t=async(t,s=null)=>{t.classList.remove("hidden"),await a("enter",t,s)},s=async(t,s=null)=>{await a("leave",t,s),t.classList.add("hidden")},a=async(t,s,a)=>{const c=s.dataset,o=a?`${a}-${t}`:t;let h=`transition${t.charAt(0).toUpperCase()+t.slice(1)}`;const u=c[h]?c[h].split(" "):[o],d=c[`${h}Start`]?c[`${h}Start`].split(" "):[`${o}-start`],l=c[`${h}End`]?c[`${h}End`].split(" "):[`${o}-end`];e(s,u),e(s,d),await i(),n(s,d),e(s,l),await r(s),n(s,l),n(s,u)},e=(t,s)=>{t.classList.add(...s)},n=(t,s)=>{t.classList.remove(...s)},i=()=>new Promise((t=>{requestAnimationFrame((()=>{requestAnimationFrame(t)}))})),r=t=>new Promise((s=>{const a=getComputedStyle(t).transitionDuration.split(",")[0],e=1e3*Number(a.replace("s",""));setTimeout((()=>s()),e)}));class c{constructor(){this.stack=[],this.executeInProgress=!1}addToStack(...t){this.stack=[...this.stack,...t]}clearStack(){this.stack=[]}nextInstruction(){if(0===this.stack.length)return;const[t,...s]=this.stack;return this.stack=s,t}async executeStack(){this.executeInProgress=!0;const t=this.nextInstruction();if(t)return await t(),void await this.executeStack();this.executeInProgress=!1}}export{c as A,r as a,t as e,s as l,i as n}